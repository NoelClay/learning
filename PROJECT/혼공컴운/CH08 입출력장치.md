## 08-1 장치 컨트롤러와 장치 드라이버<br><br>
### 장치 컨트롤러<br>
다양한 여러 장치들은 각자의 속도, 처리량, 요구 데이터 등이 전부 다르기 때문에 이걸 CPU가 각 장치마다 맞춤형으로 맞춰 줄 수가 없다. 그래서 중간 다리 역할을 하는 녀석이 장치 컨트롤러이다.<br>
장치 컨트롤러를 그러기 위해 기본적으로 저장 장치가 필요하다. CPU에 보낼 데이터, 지금 장치의 상태 등을 저장해야 되기 때문임. 장치 컨트롤러 내부에는 데이터 레지스터, 상태 레지스터, 제어 레지스터가 있음<br>
데이터 레지스터: 입출력 장치가 CPU에 보내고 싶은 데이터를 모아 놓는 공간. 출력의 경우에는 그 반대<br>
상태 레지스터: 입출력 장치가 대기 상태인지, 아직 막 작업 중인 상태인지 등을 저장<br>
제어 레지스터: CPU가 입출력 장치에 보낸 명령을 저장하는 공간<br>

### 장치 드라이버<br>
장치 컨트롤러가 CPU와 다양한 입출력 장치들이 서로 소통하기 위한 하드웨어적 장치였다면, 장치 드라이버는 중개 소프트웨어이다.<br>
OS가 기본적으로 장치 드라이버를 인식하여 설치해야하며, 설치가 안되었다면, 그 어떤 입출력 장치도 소통할 수 없다.<br>

### 확인 문제<br>
	1. 1번, 3번
	2. 2번
	3. 장치 컨트롤러, 프로그램
	4. 2번

<br>

---

<br>

## 08-2 다양한 입출력 방법<br><br>
### 프로그램 입출력<br>
프로그램이 입출력 장치를 컨트롤 하는 경우에 프로그램 입출력 방식이라고 함.<br>
장치 컨트롤러 내부에는 CPU와 소통하기 위한 레지스터들이 있는데, 제어 레지스터에 명령어를 쓰고, 그 명령어로 입출력 장치가 인식하여 상태 레지스터가 바뀌고, 상태 레지스터가 바뀌면 CPU가 입출력 장치에 보내고 싶은 데이터가 써지거나 혹은 데이터 레지스터에 있는 데이터를 CPU가 읽는 방식으로 동작하게됨.<br>
그런데 여기서 결국 CPU는 메인보드에 부착된 어떤 입출력 장치의 장치 컨트롤러의 레지스터에 접근하고자 할때는 고유한 주소값으로 접근해야 될텐데. 그 방법이 두 가지가 있음. <br>
첫째, CPU는 메모리와 소통한다. 이런 메모리와 소통하는 기존 방식과 다르지 않은 명령어와 주소로 입출력 장치와 소통하는 memory mapped I/O 방식이다. 메모리 일부 공간에 입출력 장치 레지스터의 주소랑 메핑된 공간을 할당하여, 마치 그 공간이 장치 컨트롤러의 공간인냥 사용하는 방법<br>
둘째, 메모리에 접근하는 방법은 시스템 버스의 데이터 버스, 제어버스, 주소버스 를 이용하여 필요할때 메모리에 접근하는 방식이다. 이것처럼 입출력 장치들을 묶어서 소통할 수 있는 버스를 입출력장치 버스를 둠으로 써 모든 입출력 장치에 접근하는 방법을 뚫는 방법. 이는 메모리와 소통할때 쓰이는 일반적인 명령어 집합이 아닌 다른 명령어 특히 다른 오퍼랜드를 사용 할 수 밖에 없는 방식이다. 이를 isolated I/O 고립형 입출력 방식이라고 한다.<br>

### 인터럽트 기반 입출력<br>
프로그램이 인터럽트를 발생시킬 수도 있고, 하드웨어가 인터럽트를 발생시킬 수도 있다. 하여간 인터럽트를 통해 CPU가 클럭 신호마다 체크하여 입출력 장치와 적절한 소통을 하는 방식이다.
### DMA 입출력<br>
