
# 05-1 빠른 CPU를 위한 설계 기법<br><br>

## 클럭

클럭 뜻. 단순히 시계 그자체가 클럭. 하지만 CPU에서 일반적으로 클럭은 `클럭 신호` 혹은 `클럭 속도` 정도로 사용된다.

### 클럭 신호

정체: 고주파 전기 펄스.

역할: 규칙적으로 0과 1을 전환. 여기서 이진코드로 이루어진 데이터들이 0과 1로 구성되어 있다고 해서 그녀석들과 착각 하면안됨.  클럭신호의 0과 1은 일정한 주기로 반복된다는 것이 중요. 동작 타이밍을 정의하는것. 지휘 역할. 트리거 역할. 동기화 역할(명령어 문법과 데이터 처리, 그 다음 데이터의 연속성 처리에서 무결성 확보)

어떻게 만드는가? : 석영압전 효과를 가지고 있음. 압력을 가하면 전류가 흐름. 그 반대로 전류를 흘리면 수축 팽창하며 일정한 진동수를 발산함. 이 진동수가 일정한걸 이용하여 프로그래밍의 동기화에 이용하는것이 지금 CPU들의 원리

처음부터 CPU에 활용된것은 아니고 이런 클럭신호를 이용하여 쿼츠 시계가 발명된것이 시초. 이후 일정한 주기가 필요한 GPS, 아날로그 TV 등 여러 일정 주기 생성자로 석영 압전효과가 많이 활용됨.

### 클럭 속도

위의 클럭 신호가 1초 동안 몇번을 진동하는지를 나타내는게 클럭 속도. 빠르면 빠를 수록 해당 CPU는 일정 전력 이상에서 명령어 처리를 할 수 있음을 의미. 하지만 무한정 높일 수 없는 이유는, 전력 소모가 많을 수록 발열이 기하 급수적으로 올라가서 일정 발열 이상에서는 저항이 높아져 전류 효율이 안나오고, 성능이 역행하게 됨. CPU의 성능은 결국 같은 전력을 소모할때 더 높은 클럭을 내는 기술에서 CPU 성능이 결정됨

#### 클럭 속도는 일정하지 않다

클럭 신호가 주기적으로 진동한다는건 계속해서 전력을 소모한다는 뜻. 전력 소모를 줄이기 위해서는 저전력으로 클럭 속도가 내려가고, 고성능을 뽑기 위해서는 전력을 증가시켜 빠르게 진동하게 한다. 이를 `언더클러킹`, `오버클러킹` 이라고 함.

<br>

## 코어와 멀티코어

### 코어

앞서 공부했던 CPU에 관한 공부들이 사실 전부 코어에 대한 공부이다.
	ALU + 제어장치 + 레지스터 + 버스
이 조합은 사실상 코어에 관련한 내용이다. CPU의 근본은 1코어 CPU이다. 하지만, 요즘 CPU는 거의 멀티 코어 CPU이다.

### 멀티코어

코어가 여러개인 CPU를 멀티코어 CPU라고 한다. 성능 향상의 방법으로, 진동수를 무지막지하게 늘리는 원코어 CPU보다 적절한 진동수의 코어를 여러개 가진 CPU가 성능향상에 더 효율적이기 때문

<br>

## 스레드와 멀티스레드

### 스레드

뜻 : 실행의 흐름 단위

종류 : 일반적으로 `하드웨어 스레드`, `소프트웨어 스레드`로 구분함.

#### 소프트웨어 스레드

CPU랑은 상관 없이, 프로그램이 실행되고 나서 동작할 흐름을 스레드를 생성하여 동시 작업시키는걸 의미함. 예를들어 배경음악 재생기 같은게 예시가 될 수 있다. 프로그램 시작하자마자, 사용자의 입력을 기다리면서 뭔가를 그려주는 렌더링이 돌아감과 동시에 배경음악파일을 해석하여 재생하는 녀석도 동시에 돌아간다. 이때 반드시 스레드로 돌려줘야지 사용자 입력과 배경 음악 재생 2가지가 돌아간다.

#### 하드웨어 스레드

CPU의 관점에서 명령어를 처리하는게 코어라고 했다. 그런데 코어가 하나의 명령어가 아니라 마치 독림된 2개의 코어인거 마냥 실행의 단위를 2개 이상 처리할 수 있다. 이때 멀티코어 안의 멀티 코어라고 해서 멀티멀티코어가 아니라, 멀티 스레드라고 표현한다. 즉 한마디로, CPU안에 코어가 하나 있던 시절엔 굳이 코어 개념이 필요없었는데 멀티코어 때문에 생겨났고, 단일 스레드 개념일땐 필요없던게 이젠 멀티 스레드를 지원하기에 또 용어가 구별되어 생겨난거라고 볼 수 있음.

CPU를 프로세서라고 표현하고, 이를 각각 멀티코어 프로세서, 멀티스레드 프로세서라고 명명하기도 한다.

##### 멀티스레드 프로세서를 위한 조건

코어 하나안에 마치 코어 2개인양 처리를 하기 위해서는 반드시 2개의 명령어를 저장하고 있을 레지스터들이 필요하다. 즉 명령어 하나를 처리하기 위한 최소 단위의 레지스터들을 묶어서 레지스터 셋이라고 표현한다면, 이러한 레지스터셋이 2개이상이면 멀티스레드 프로세서를 위한 조건을 만족한다. ALU나 제어장치는 스태이트리스 즉 상태를 저장하고 있을 필요가 없는 부품이다. 빠른속도로 왔다리 갔다리 해도 상관이 없다. 하지만 상태를 저장하고 있어야 되는 레지스터는 최소 조건을 만족하기위해 확실하게 구분된 여러개가 필요할 수 밖에 없는 이유이다.

<br>

## 확인 문제

1.  3번
2.  4번
3.  소프트웨어, 하드웨어
4. 코어

<br>

---

<br>

# 05-2 명령어 병렬 처리 기법<br><br>

<br>

## 명령어 파이프라인

정의: 명령어를 코어가 처리 가능한 양의 파이프라인에 넣고서 각 기관들이 쉴새없이 돌아가게 하여 동시에 여러 명령어를 처리하는 기법. 

왜?: 코어는 하나의 명령어만 처리하기에는 너무 강력하다. 그래서 여러 명령어를 동시에 처리하는 것.
-> 그럼 성능좋은 CPU가 그냥 한 명령어 빠르게 처리하고 다음 명령어 순서대로 처리하면 되는거 아닌가?
-> 그렇지 않다. 코어는 ALU+ 제어장치 +레지스터 뿐만 아니라, 메모리와 하드디스크 및 기타 키보드 마우스 모니터라는 장치들도 이런 명령어에 복합적으로 관여할 수 있기에, 아무리 빠른 코어라고 해도 명령어를 한클럭 안에 해결하는 것은 불가능이다. 일부러 할 수 있어도 무결성을 위하여 클럭 단위로 쪼개서 작동한다. 
-> 무결성을 위해 최소로 fetch -> decode -> execute -> memory access -> write back 의 과정은 거진 한클럭 단위로 작동하게 한다. 클럭의 장점을 활용하는 것. 성능이 좋아도 이렇게 나눠서 접근하면, 한 CPU가 일정 클럭동안 무엇을 하고 있을지 대강짐작이 된다. 
-> 물론 성능이 좋으면 한클럭당 어마무시하게 많은 파이프라인을 돌릴 것이다. 하지만 그렇다고 해서 명령어를 한 클럭안에 해결하는 동작 같은건 위험성이 더 크다.

### 명령어 파이프라인의 위험(hazard)

그렇다고 클럭에 따라서 명령어를 수행하는 것이 안전한것과는 별개로 한 클럭 안에 여러 파이프라인을 수행하는 것이 마냥 안전한건 아니다.

#### 데이터 위험

정의: 데이터 간에 의존성 때문에 발생. 마냥 파이프라인에 막 추가 할 수 없는 이유. 선행 명령어의 결과 데이터를 이용해야 되는 경우가 있을 수 있기 때문

해결 기법
1. 컴파일러 최적화: 컴파일러가 최대한 이런 위험이 발생하지 않게끔 명령어 리오더링을 실시.
2. 스텔링: stalling. 기다리기. 필요한 데이터가 준비되면 동작하게끔 명령어의 실행을 유보하는 형태를 취함

#### 제어 위험

정의: 소스파일만 보면 분명 다음 차례 명령어들이 뭔지 정의되어 있는데, branch나 jump 명령어 때문에 다음 명령어가 뭔지 예측하기 힘들어서 파이프라이닝에 함부로 추가하기 어려운 경우

해결기법
1. 분기 예측: 이번 명령어 다음에 올 명령어가 어떤건지 미리 예측해놓는 기법을 이용하여 제어 위험 극복

#### 구조적 위험

정의: 명령어 파이프라이닝을 과도하게 수행할 경우, CPU 내에 한드웨어를 효과적으로 사용하기 위한 파이프라이닝이었으나, 같은 타이밍에 한 부품을 여러 명령어가 사용하려고 시도할때 발생

해결기법
1.  파이프라인 조정: 단계조정, 사용 시점 조정 하여 동시에 접근하는 것을 막아야만 한다.

<br>

## 슈퍼스칼라

명령어 파이프라인을 인출단계 수행 여러개 해석단계 수행 여러개 등 코어의 각 부품들이 더 쉬지않고 일하게끔 중복ㄷ

<br>

## 비순차적 명령어 처리

<br>

## 확인문제

<br>

---

<br>

# 05-3 CISC와 RISC<br><br>

<br>

## 명령어 집합

<br>

## CISC

<br>

## RISC

<br>

## 확인문제

