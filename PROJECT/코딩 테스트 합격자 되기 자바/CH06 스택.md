## 목표

	1. 스택 개념 이해
	2. 그걸 토대로 ADT 작성
	3. 기반으로 문제 해결 가능


## 스택의 개념

stack: 쌓다

데이터를 쌓아놓고 사용하는 형태라는게 stack의 어원

먼저 들어간게 나중에 나오니까 이런걸 LIFO: Last In First Out 후입선출이라고 함.

넣는 걸 put 빼는 걸 pop


스택의 정의

개념에서 스택이 어떤식으로 돌아가는지 알았다면 다음 단계 정의 단계

## ADT: Abstract Data Type 추상 자료형

인터페이스만 있고, 실제 소스코드는 없는 상태이다. 즉 설계만 해보자는거다.

ADT를 만들줄 아는거에서 정의를 이해한다고 볼 수 있다.

2가지를 고려한다. 주의 아직 구체적 구현까지는 생각하지말라. 개념적으로 생각만.

구체적 구현을 고려하다 필요한게 있다면 돌아와서 그때 다시 설계를 생각해도 좋다.

- 필요한 연산

- 필요한 상태

연산

void push( Object obj ): 값을 넣는 행위.

Object pop(): 값을 빼는 행위.

boolean isFull(): 꽉 차있는지

boolean isEmpty(): 비어있는지

상태

int top(): 라스트인덱스 상태

Object[] objArray = new Object[maxSize]: 데이터가 저장될 공간

## 스택의 세부 구현

ADT에서 멈추는 것만해도 많이 아는거고 사용법만 알면 사용해서 풀면 된다. 그런데 세부구현을 직접해보거나 자세히 아는것은 시간은 많이 잡아먹고 수명도 깎아먹지만, 도움이 무조건 된다.

기업 코딩테스트는 안그러지만, 대회에서는 STL이나 util 라이브러리를 사용하지 못하게 막는 경우도 있기에 그때는 진짜 구현까지 해야된다.

실제 범용성있게 구현하는걸 안하더라도 개념을 구현하는거나 의사코드만 구현해도 도움되니 최소 의사 코드 수준으로 구현하라.

책에서는 의사코드 까지는 알려주지 않고 좀 더 세부적인 동작을 설명하고 넘어가는 듯

실제 문제풀때나 새로운 알고리즘을 접할때 도움은 되지만 스택을 사용하는데 직접적인 영향을 주지는 않으니까..

but 나는 할거다

참조

제네릭 클래스 제네릭 함수 문법네릭 클래스 제네릭 함수 문법

[https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%ADGenerics-%EA%B0%9C%EB%85%90-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%B3%B5%ED%95%98%EA%B8%B0](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%ADGenerics-%EA%B0%9C%EB%85%90-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%B3%B5%ED%95%98%EA%B8%B0)

제네릭 배열을 만들 수 없는 이유

[https://pompitzz.github.io/blog/Java/whyCantCreateGenericsArray.html#%E1%84%92%E1%85%A7%E1%86%BC%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5](https://pompitzz.github.io/blog/Java/whyCantCreateGenericsArray.html#%E1%84%92%E1%85%A7%E1%86%BC%E1%84%87%E1%85%A7%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5)


```

public class knyStack<T> {

//먼저 상태 3놈. top array maxsize

	int top = -1; //최초 0인덱스에는 아직 도달도 못했다. 그래서 -1

	int maxSize = 100; //일단 최초 100...

	// 생성자에 넣어서 최대 사이즈 정해줄거 0~maxSize-1 까지가 유효 인덱스

	List<T> innerList = new ArrayList<>(maxSize); //배열을 쓰려고 했는데 제네릭으로는 배열을 못쓴다.

	public knyStack(int max){

		this.top = -1; //최초 값

		this.maxSize = max;

		this.innerList = new ArrayList<>(max); 

//최대 사이즈 제한!! 일단 이렇게 할래 원래는 배열용으로 최대 크기 받을려고 했는데

//못하게되어서... 실제 로우코드는 반드시 최대크기가 존재할거기 때문에

//물론 동적으로 사이즈를 늘리겠지만, 나는 isFull 상태가 존재하는걸 만들고 싶음.

	}

	public void push(T t){

		if(isFull()) System.err.println("full stack!!");

		else innerList.set(++this.top, t);

	}

public T pop(){

if(isEmpty()) System.err.println("empty stack!!");

else return innerList.get(this.top--);

}

	public boolean isEmpty() { return this.top<=-1; }

	public boolean isFull() { return this.top>=this.maxSize; }

}

```

stack 클래스 사용하기

Stack<Integer> stack = new Stack<>(); //스택기능 사용할수 있음. 동적크기 구현되어있음.

stack.push(1); //추가

stack.pop(); //빼기

stack.peek() //빼지 않고 조회

stack.size() //크기 조회

몸풀기 문제

핵심

2. 왜 스택을 사용하는 지 아는가?

3. 스택을 어떤식으로 사용하면 되는지 아는가?


올바른 괄호 lv2 -> 성공

[https://school.programmers.co.kr/learn/courses/30/lessons/12909?language=java](https://school.programmers.co.kr/learn/courses/30/lessons/12909?language=java)

[나의 풀이]

//나누어 생각하기

// 일단 무조건 짝수개로 들어와야겠네 홀수개면 걍 false

// 짜수로 왔다 치고 짝을 지어주면 되는거네 스택으로 풀면 쉽게 풀리는이유는

// 1. (열린 괄호는 항상 push )닫힌 괄호는 항상 pop으로 일반화 할수 있음.

// 2. 제약조건도 간단히 풀리는 이유는 비어있는데 pop한 결과로 null을 유도할수 있고

// 3. 다 끝났는데 짝지어지지 않은 쉐리가 있으면 그냥 false 하면됨.

//제약조건으로 생각하기

// 10만개 인데 복잡도가 n이라서 상관없음

//의사코드

// 1. 핵심인 stack을 생성하고 안에 자료형은 char

// 2. String을 char 단위로 탐색하면서

// 2-1. 열린괄호는 push 닫힌괄호는 pop을 한다.

// 2-1-1. 이때 pop의 결과로 열린괄호가 안나온다면 끝 false

// 3. 다 정상 작동했는데 isEmpty() 결과가 곧 답이다.

import java.util.*;

class Solution {

boolean solution(String s) {

// 1. 핵심인 stack을 생성하고 안에 자료형은 char

Stack<Character> stack = new Stack<>();

// 2. String을 char 단위로 탐색하면서

for(int i=0; i<s.length(); i++){

char c = s.charAt(i);

// 2-1. 열린괄호는 push 닫힌괄호는 pop을 한다.

switch(c){

case '(':

stack.push(c);

break;

// 2-1-1. 이때 pop의 결과로 열린괄호가 안나온다면 끝 false

default :

if(stack.isEmpty()) return false;

else stack.pop();

break;

}

}

// 3. 다 정상 작동했는데 isEmpty() 결과가 곧 답이다.

return stack.isEmpty();

}

}


[저자 풀이]

중요한건 스택을 떠올린 이유가 명확하냐이다.

4. 닫힌 괄호의 짝을 찾을때 임의의 위치의 열린괄호만 있으면 되는게 아니라

5. 정확히 가장 최근에 저장된 괄호와 짝을 이루어야한다는거다.

6. 그게 LIFO 아이디어이다. 순서가 중요


10진수를 2진수로 변환하기 lv1 [저자출제] -> 정답

문제

10진수를 입력받아 2진수로 변환해 반환하는 solution()함수를 구현하세요.

제약

decimal은 1이상 10억 미만의 자연수

입출력 예

decimal	반환값 \
10		1010 \
27		11011 \
 \
[나의 풀이]

//나누어 생각하기

//계속 2로 나누면 되지 않을까 싶네 그리고 2진수는 문자열인가? 암튼 저장을하면될듯

//10/2 = 5 10%2 =0 -> 0

//5/2 = 2 5%2 =1 -> 10

//2/2 = 1 2%2 = 0 -> 010

//1/2 = 0 1%2 = 1 -> 1010

//그리고 몫이 0인 순간에 반환하면 된다. 가만 보니까 LIFO 자료구조면 편하다.

//마지막에 넣은게 순서가 가장 먼저 나오니까.

//스트링을 반환하는거네. 오케이

//제약조건으로 생각하기

//10억미만이기에 속도 고려하여 n회씩으로 끊어야된다. n+m

//의사코드

//1. int를 담을 스택

//2. 계속해서 나눈 결과를 저장하고 나머지는 push하고 0이될때까지

//3. 역순으로 pop한 결과가 정답

import java.util.*

public Class Solution{

public static void main(String[] args){

int decimal = Integer.parseInt(args[0]);

this.solution(decimal);

}

public static String soulution(int decimal){

//1. int를 담을 스택

Stack<Integer> stack = new Stack<>();

int temp = decimal;

//2. 계속해서 나눈 결과를 저장하고 나머지는 push하고 0이될때까지

while(temp!=0){

stack.push(temp%2);

temp/=2;

}

//3. 역순으로 pop한 결과가 정답

StringBuilder s = new StringBuilder();

while(!stack.isEmpty()){

s.append(stack.pop());

}

return s.toString();

}

}

[저자 풀이]

다를게 없다.


합격자가 되는 모의 테스트

괄호 회전하기 lv2
