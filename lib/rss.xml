<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[learning]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>learning</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 05 Feb 2025 07:50:46 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 05 Feb 2025 07:50:43 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Drawing 2025-01-31 16.40.18]]></title><description><![CDATA[ 
 수실수허수유리수무리수 == 순환하지 않는 무한 소수정수양의 정수음의 정수0정수 아닌 유리수유한 소수순환 소수]]></description><link>excalidraw\drawing-2025-01-31-16.40.18.excalidraw.html</link><guid isPermaLink="false">Excalidraw/Drawing 2025-01-31 16.40.18.excalidraw.md</guid><pubDate>Fri, 31 Jan 2025 07:52:22 GMT</pubDate></item><item><title><![CDATA[CH02 복소수]]></title><description><![CDATA[ 
 <br><br><br>![image](./PROJECT/50일수학/Pasted image 20250131165415.png)
<img alt="PROJECT/50일수학/Pasted image 20250131165415.png" src="project\50일수학\pasted-image-20250131165415.png"><br><br>대소 판별이 가능하다는 것은 수직선 위에 표시가 가능하다는 거고, 서로 뺐을때의 결과가 예측이 된다는것<br>
서로 얼마만큼 떨어져 있는지 가늠이 되어야 뺄셈이 가능하기 때문<br>
<br>
허수는 그게 불가능하다. 수직선위에 표현이 불가능하다.<br><br><br>원점 0을 기준으로 얼마나 떨어져 있는지 == 거리<br>
따라서 마이너스는 존재 할 수 없다. 항상 0보다 크거나 같다<br>
절대값  벗기라고 있는 것이다. 벗기려면??? -&gt; 내부 값의 부호를 알아야 벗기든 말든 하지<br>
명확하지 않으면 절대 벗길 수 없다.<br><br><br>따라서 나눗셈이나 뺄셈이 보이면 음수의 덧셈, 역수의 곱셈으로 바꾼뒤에 교환 결합 법칙을 적용해 버린다.<br><br>순환소수는 분수로 표현이 가능하다. 다만 분모가 10의 거듭제곱꼴로 만드는게 불가능하여 10진수로 나누어떨어지지 못한 탓에 무한히 반복될 뿐이다.<br>
<br>
분수꼴로 만드는 방법<br>
 일때,  을 이용하여 빼는 방법이다.  이고,  이므로 이 된다.<br><br><br>어떤 수를 만들때 제곱하여 만들 수 있는 수. 즉 4의 제곱근은 +2 혹은 -2 이다.<br>
 기호를 제곱근이라고 표현하기도 하고 루트라고 표현하기도 한다.<br><br>-&gt; 말장난: 제곱근 a<br>
-&gt; <br>
-&gt; 말장난: a의 제곱근<br>
-&gt; <br><br><br>첫째, <br>
-&gt; 제곱근을 벗기는 정의 그 자체<br>
<br>
둘째, <br>
-&gt; 제곱근을 벗기는것과 구별. 얘는 일단 a를 먼저 제곱을하고 나니 항상 양수가 되어 있을 것이고, 해당 값에 루트를 씌우다보니 루트가 자연스레 벗겨지는 거<br>
<br>
셋째,  <br>
-&gt; 첫째 성질로 증명, 마이너스의 제곱은 플러스라는 사실만 바뀜.<br>
<br>
넷째, <br>
-&gt; 둘째 성질로 증명, 마이너스의 제곱은 플러스가 된다는 사실만 추가되었을뿐 <br><br><br>a&gt;0 ,b&gt;0일때 <br>
<br>
<br><br><br>case1 분모가 단항 루트일때 <br>
같은 루트 곱해서 루트 없애기<br><br>
case2 분모가 다항 루트일때<br>
합 곱하기 차 공식을 이용하여  꼴로 만들어 루트 제거<br><br><br><br>실수가 아닌 모든 수가 허수이다. 따라서 실수의 성질을 만족하질 못한다. <br>
수직선 위에 양수로도 0으로도 음수로도 표현 불가능하다. <br>
모든 실수는 제곱하면 0보다 크거나 같다. 하지만 허수는 음수가 되는 이상한 개념이다<br><br><br><br>허수를 만드는 녀석. 정체는  이다.  로 표현.<br>
 이 자식은 허수. 도 허수.  이것도 허수. 즉 i가 껴들어가는 순간 전부 허수가 된다.<br><br><br><br>실수가 될수도 허수가 될수도 있는 모든 수를 복소수라고 한다. 실수와 허수를 복소수라고 함. <br><br><br><br>첫째,       <br>
둘째, 연속된 지수 4개의 합은 0 <br><br><br><br>복소수는 실수와 허수를 모두 포함하여 복소수이다 a+bi 는 모두 복소수이다. a는 실수부이자 실수. b는 허수부이자 실수. i만 허수단위. 이때 a의 값 b의 값에 의해 실수가 될지 허수가 될지 결정됨.<br>
3 = 실수 = 양의 정수 = 복소수 = 3 + 0i 실수부는 3 허수부는 0<br>
 = 실수 = 무리수 = 복소수 =  실수부는  허수부는 0<br>
2i = 허수 = 순허수 = 복소수 = 0 + 2i 실수부는 0 허수부는 2<br>
= 허수 = 복소수 =  실수부는 1 허수부는 루트3<br><br><br>
<br>z가 실수다 =&gt; b = 0
<br>z가 허수다 =&gt; b != 0
<br>z가 순허수다 =&gt; a = 0 and b != 0
<br><br><br><br>상등 : 완전히 똑같다 == 실수부와 허수부까지 전부 똑같다.<br>
복소수의 대소비교: 불가능. 수직선위에 그릴 수 있는 실수가 아니기때문이다. 실수부의 크기가 큰거로는 불가능한가? 불가능하다. 대수의 법칙이 이를 허용하지 않는다. <br>
유일하게 허수의 경우 상등만이 존재하는데 상등의 조건은 a + bi 에서 두 수가 a와 b가 전부 일치하는 경우이다.<br><br><br><br>왜 중요한가? 켤레복소수의 곱은 합차 공식에 의해서 허수를 실수화 하는 재료이기 때문.<br><br><br>덧셈은 실수부끼리 허수부끼리 따로 계산. 곱셈에 있어 분모는 항상 실수화 이때 켤레복소수를 활용]]></description><link>project\50일수학\ch02-복소수.html</link><guid isPermaLink="false">PROJECT/50일수학/CH02 복소수.md</guid><pubDate>Wed, 05 Feb 2025 06:48:03 GMT</pubDate><enclosure url="project\50일수학\pasted-image-20250131165415.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;project\50일수학\pasted-image-20250131165415.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ch05 CPU 성능 향상 기법]]></title><description><![CDATA[ 
 <br><br><br>클럭 뜻. 단순히 시계 그자체가 클럭. 하지만 CPU에서 일반적으로 클럭은 클럭 신호 혹은 클럭 속도 정도로 사용된다.<br><br>정체: 고주파 전기 펄스.<br>역할: 규칙적으로 0과 1을 전환. 여기서 이진코드로 이루어진 데이터들이 0과 1로 구성되어 있다고 해서 그녀석들과 착각 하면안됨.  클럭신호의 0과 1은 일정한 주기로 반복된다는 것이 중요. 동작 타이밍을 정의하는것. 지휘 역할. 트리거 역할. 동기화 역할(명령어 문법과 데이터 처리, 그 다음 데이터의 연속성 처리에서 무결성 확보)<br>어떻게 만드는가? : 석영압전 효과를 가지고 있음. 압력을 가하면 전류가 흐름. 그 반대로 전류를 흘리면 수축 팽창하며 일정한 진동수를 발산함. 이 진동수가 일정한걸 이용하여 프로그래밍의 동기화에 이용하는것이 지금 CPU들의 원리<br>처음부터 CPU에 활용된것은 아니고 이런 클럭신호를 이용하여 쿼츠 시계가 발명된것이 시초. 이후 일정한 주기가 필요한 GPS, 아날로그 TV 등 여러 일정 주기 생성자로 석영 압전효과가 많이 활용됨.<br><br>위의 클럭 신호가 1초 동안 몇번을 진동하는지를 나타내는게 클럭 속도. 빠르면 빠를 수록 해당 CPU는 일정 전력 이상에서 명령어 처리를 할 수 있음을 의미. 하지만 무한정 높일 수 없는 이유는, 전력 소모가 많을 수록 발열이 기하 급수적으로 올라가서 일정 발열 이상에서는 저항이 높아져 전류 효율이 안나오고, 성능이 역행하게 됨. CPU의 성능은 결국 같은 전력을 소모할때 더 높은 클럭을 내는 기술에서 CPU 성능이 결정됨<br><br>클럭 신호가 주기적으로 진동한다는건 계속해서 전력을 소모한다는 뜻. 전력 소모를 줄이기 위해서는 저전력으로 클럭 속도가 내려가고, 고성능을 뽑기 위해서는 전력을 증가시켜 빠르게 진동하게 한다. 이를 언더클러킹, 오버클러킹 이라고 함.<br><br><br><br><br>앞서 공부했던 CPU에 관한 공부들이 사실 전부 코어에 대한 공부이다.
ALU + 제어장치 + 레지스터 + 버스
이 조합은 사실상 코어에 관련한 내용이다. CPU의 근본은 1코어 CPU이다. 하지만, 요즘 CPU는 거의 멀티 코어 CPU이다.<br><br>코어가 여러개인 CPU를 멀티코어 CPU라고 한다. 성능 향상의 방법으로, 진동수를 무지막지하게 늘리는 원코어 CPU보다 적절한 진동수의 코어를 여러개 가진 CPU가 성능향상에 더 효율적이기 때문<br><br><br><br><br>뜻 : 실행의 흐름 단위<br>종류 : 일반적으로 하드웨어 스레드, 소프트웨어 스레드로 구분함.<br><br>CPU랑은 상관 없이, 프로그램이 실행되고 나서 동작할 흐름을 스레드를 생성하여 동시 작업시키는걸 의미함. 예를들어 배경음악 재생기 같은게 예시가 될 수 있다. 프로그램 시작하자마자, 사용자의 입력을 기다리면서 뭔가를 그려주는 렌더링이 돌아감과 동시에 배경음악파일을 해석하여 재생하는 녀석도 동시에 돌아간다. 이때 반드시 스레드로 돌려줘야지 사용자 입력과 배경 음악 재생 2가지가 돌아간다.<br><br>CPU의 관점에서 명령어를 처리하는게 코어라고 했다. 그런데 코어가 하나의 명령어가 아니라 마치 독림된 2개의 코어인거 마냥 실행의 단위를 2개 이상 처리할 수 있다. 이때 멀티코어 안의 멀티 코어라고 해서 멀티멀티코어가 아니라, 멀티 스레드라고 표현한다. 즉 한마디로, CPU안에 코어가 하나 있던 시절엔 굳이 코어 개념이 필요없었는데 멀티코어 때문에 생겨났고, 단일 스레드 개념일땐 필요없던게 이젠 멀티 스레드를 지원하기에 또 용어가 구별되어 생겨난거라고 볼 수 있음.<br>CPU를 프로세서라고 표현하고, 이를 각각 멀티코어 프로세서, 멀티스레드 프로세서라고 명명하기도 한다.<br><br>코어 하나안에 마치 코어 2개인양 처리를 하기 위해서는 반드시 2개의 명령어를 저장하고 있을 레지스터들이 필요하다. 즉 명령어 하나를 처리하기 위한 최소 단위의 레지스터들을 묶어서 레지스터 셋이라고 표현한다면, 이러한 레지스터셋이 2개이상이면 멀티스레드 프로세서를 위한 조건을 만족한다. ALU나 제어장치는 스태이트리스 즉 상태를 저장하고 있을 필요가 없는 부품이다. 빠른속도로 왔다리 갔다리 해도 상관이 없다. 하지만 상태를 저장하고 있어야 되는 레지스터는 최소 조건을 만족하기위해 확실하게 구분된 여러개가 필요할 수 밖에 없는 이유이다.<br><br><br><br>
<br>3번
<br>4번
<br>소프트웨어, 하드웨어
<br>코어
<br><br><br><br><br><br><br><br><br><br>정의: 명령어를 코어가 처리 가능한 양의 파이프라인에 넣고서 각 기관들이 쉴새없이 돌아가게 하여 동시에 여러 명령어를 처리하는 기법. <br>왜?: 코어는 하나의 명령어만 처리하기에는 너무 강력하다. 그래서 여러 명령어를 동시에 처리하는 것.
-&gt; 그럼 성능좋은 CPU가 그냥 한 명령어 빠르게 처리하고 다음 명령어 순서대로 처리하면 되는거 아닌가?
-&gt; 그렇지 않다. 코어는 ALU+ 제어장치 +레지스터 뿐만 아니라, 메모리와 하드디스크 및 기타 키보드 마우스 모니터라는 장치들도 이런 명령어에 복합적으로 관여할 수 있기에, 아무리 빠른 코어라고 해도 명령어를 한클럭 안에 해결하는 것은 불가능이다. 일부러 할 수 있어도 무결성을 위하여 클럭 단위로 쪼개서 작동한다.
-&gt; 무결성을 위해 최소로 fetch -&gt; decode -&gt; execute -&gt; memory access -&gt; write back 의 과정은 거진 한클럭 단위로 작동하게 한다. 클럭의 장점을 활용하는 것. 성능이 좋아도 이렇게 나눠서 접근하면, 한 CPU가 일정 클럭동안 무엇을 하고 있을지 대강짐작이 된다.
-&gt; 물론 성능이 좋으면 한클럭당 어마무시하게 많은 파이프라인을 돌릴 것이다. 하지만 그렇다고 해서 명령어를 한 클럭안에 해결하는 동작 같은건 위험성이 더 크다.<br><br>그렇다고 클럭에 따라서 명령어를 수행하는 것이 안전한것과는 별개로 한 클럭 안에 여러 파이프라인을 수행하는 것이 마냥 안전한건 아니다.<br><br>정의: 데이터 간에 의존성 때문에 발생. 마냥 파이프라인에 막 추가 할 수 없는 이유. 선행 명령어의 결과 데이터를 이용해야 되는 경우가 있을 수 있기 때문<br>해결 기법<br>
<br>컴파일러 최적화: 컴파일러가 최대한 이런 위험이 발생하지 않게끔 명령어 리오더링을 실시.
<br>스텔링: stalling. 기다리기. 필요한 데이터가 준비되면 동작하게끔 명령어의 실행을 유보하는 형태를 취함
<br><br>정의: 소스파일만 보면 분명 다음 차례 명령어들이 뭔지 정의되어 있는데, branch나 jump 명령어 때문에 다음 명령어가 뭔지 예측하기 힘들어서 파이프라이닝에 함부로 추가하기 어려운 경우<br>해결기법<br>
<br>분기 예측: 이번 명령어 다음에 올 명령어가 어떤건지 미리 예측해놓는 기법을 이용하여 제어 위험 극복
<br><br>정의: 명령어 파이프라이닝을 과도하게 수행할 경우, CPU 내에 한드웨어를 효과적으로 사용하기 위한 파이프라이닝이었으나, 같은 타이밍에 한 부품을 여러 명령어가 사용하려고 시도할때 발생<br>해결기법<br>
<br>파이프라인 조정: 단계조정, 사용 시점 조정 하여 동시에 접근하는 것을 막아야만 한다.
<br><br><br><br>명령어 파이프라인을 인출단계 수행 여러개 해석단계 수행 여러개 등 코어의 각 부품들이 더 쉬지않고 일하게끔 여러 파이프라인을 두고 돌리는 방식을 슈퍼스칼라라고 함.<br>위험성은 더 증가하지만, 동시수행 능력은 향상.<br>하드웨어, 소프트웨어 성능을 더 증가시켜야함.<br><br><br><br>현대 CPU의 새로운 개념인데 더 똑똑해진 처리 방법의 일종이다. 순차적처리에서 나오는 여러 이슈들 중에 특히 데이터 위험이 이에 많이 해당하는데, 스텔링을 해야되는 경우가 발생할때가 있다. 이때 막힘없이 처리하기위한 명령어 수행을 미리 앞당겨 수행하여 전체 흐름을 최적화는 방법이 비순차적 명령어 처리이다.<br>컴파일러가 소스코드를 빌드하듯이 명령어 처리 순서에 대한 데이터 의존성 분석 처리가 가능한 프로세서여야한다. 즉 고급 CPU여야 한다.<br><br><br><br>
<br>2번
<br>비순차적 명령어 처리, 슈퍼스칼라
<br><br><br><br><br><br><br><br><br><br>명령어 집합: instruction set
명령어 집합 구조: ISA, instruction set architecture<br>CPU가 이해할 수 있는 코드는 기계어이고 바이너리 코드이다.<br>그런데 CPU제조사는 하나만 있는게 아니다. 따라서 CPU의 언어도 여러개이다. 이런 CPU의 언어인 명령어의 집합 구조인 ISA는 여러 종류가 있다.<br>대표적인게 CISC, RISC 이다.<br><br><br><br>Complex Instruction Set Computer<br>대표적으로  x86, x86-64 등이 있음.<br>특징은 명령어의 종류가 상다하며, 이는 가변길이 명령어들이다. 여러 역할을 하는 명령어들을 이용해서 문장을 구성하니 소스코드 자체가 최적화 되어 길이가 짧게 작성가능하다. 이는 소스코드를 올려야하는 메모리 공간을 적게 차지하는 효과.<br>but 명령어 파이프라이닝을 더 많이 처리할때 CPU입장에서 점점 설계가 어려워지게 된다. 명령어 하나가 복잡한 기능을 담고 있으니, 해석하는데 오래 시간이 걸릴 수도, 메모리 접근을 더 복잡하게 할 수도 있는 형태라 딱딱 정해진 사이클에 맞춰 부품을 점유하게 하면 되는 형태가 아니라 각 명령어가 부품 점유 필요 시간이 제각각이라, 파이프라이닝 위험에 더 많이 노출되는 것.<br><br><br><br>Reduced Instruction Set Computer<br>특징은 명령어의 종류가 매우 적다는 것, 고정길이 명령어라는 점. 단순하고 역할이 구별된 명령어들을 이용해서 프로그램을 구성해야되다보니 명령어를 아주 많이 사용해야되서 메모리에 올라가야되는 용량 자체가 커지게 된다.<br>하지만, 명령어 파이프라이닝을 수행할때 명령어가 짧게 치고 빠지는 형태로 구성되어 있어 일관된 파이프라이닝을 보장한다. <br><br><br><br>
<br>4번
<br>1번
]]></description><link>project\혼공컴운\ch05-cpu-성능-향상-기법.html</link><guid isPermaLink="false">PROJECT/혼공컴운/ch05 CPU 성능 향상 기법.md</guid><pubDate>Fri, 31 Jan 2025 03:56:12 GMT</pubDate></item><item><title><![CDATA[CH06 메모리와 캐시메모리]]></title><description><![CDATA[ 
 <br><br><br>휘발성 저장장치: 전류가 차단되면 안에 있는 정보는 전부 사라짐.<br><br><br>램의 용량이 많을 수록 많은 프로그램을 메모리에 올릴 수 있음. 하지만 필요 이상은 더 이상 성능 향상 기대가 어려움.<br><br><br><br>Dynamic RAM<br>
동적램인데, 뭐가 동적이냐? -&gt; 주기적으로 내부 축전기의 전류를 흘러주어 충전해야되서 동적램이란다.<br>
-&gt;??? 램자체가 계속해서 전류를 공급해줘야 되는 거 아니야??? <br>
-&gt; 전류 공급은 그냥 기본이고, 축전기 리프레시도 추가로 해줘야 된다는 것.<br>
<br>
이렇게 불편해보여도 단점만 있는게 아니라, 오히려 장점이다.<br>
일단 기본 소비 전류자체가 낮다. 리프레시와 별개로 소비전력자체는 SRAM대비 거의 없는 편<br>
설계 최소 단위가 단순하여 집적도를 높이기 쉽다 == 대용량 늘리기가 용이하다<br>
다만 SRAM 대비 속도는 느리다.<br>
주기억장치로 사용된다<br><br><br>Static RAM<br>
전류만 공급하면 동적으로 뭔가 리프레시 같은걸 해줄 필요는 없는 램이라서 정적램이다.<br>
속도는 빠르지만, 복잡성이 커서 집적도를 높이기 어려우니 용량을 늘리기 쉽지 않다.<br>
캐시메모리에 사용된다<br><br><br>Synchronous DRAM<br>
DRAM의 일종이다. 그런데 동기화 DRAM이다. 무엇과 동기화 된다는 것인가? CPU 클럭 신호와 동기화 된다는 의미이다. 비로소 현대 CPU와 작업하기 딱인 DRAM이 등장한 것.<br><br><br>Double Data Rate SDRAM<br>
2배 대역폭 SDRAM이다. SDRAM을 다른 말로 DDR SDRAM과 구별하여 Single Data Rate SDRAM 즉 SDR SDRAM 이라고도 한다.<br>
DDR SDRAM's data rate == 2 * SDR SDRAM's data rate<br>
DDR2 SDRAM's data rate == 2 * DDR SDRAM's data rate == 4 * SDR SDRAM's data rate<br>
DDR3 SDRAM's data rate == 2 * DDR2 SDRAM's data rate == 8 * SDR SDRAM's data rate<br>
DDR4 SDRAM's data rate == 2 * DDR3 SDRAM's data rate == 16 * SDR SDRAM's data rate<br><br><br>1. 3번
2. DDR SDRAM, SRAM, DRAM, SDRAM
3. SRAM, DRAM, DRAM, SRAM
4. 2, 2
<br><br><br><br><br><br><br><br>물리주소는 진짜 하드웨어 메모리에 실제로 프로그램이 실려 있는 주소이다. 명령어나 데이터들의 실제 주소이다.<br>
<br>
논리주소는 프로그램과 CPU가 알고 있는 주소이다. 논리적으로 시작주소는 항상 0이고, 0을 기준으로 얼만큼 떨어져 있는지로 프로그램과 CPU는 불러오고 저장하려 한다<br>
<br>
왜냐하면 프로그램 실행할때마다 다를건데 대체 프로그램이 무슨 수로 알고서 자기 자신 주소를 일일히 알고 있어야하는가. 그리고 그렇게 자기 자신의 주소가 굉장히 복잡한 주소라면 그게 가독성이 좋을까?<br>
<br>
이미 앞서 공부했던 것 처럼, 베이스 레지스터라는 곳에 해당 프로그램의 물리적인 시작 주소를 저장하고 이걸 Offset으로 사용하며 변위주소지정방식 처럼 offset에 논리 주소를 더해가며 실제 메모리와 CPU는 소통하게 된다.<br>
<br>
이를 담당하는 기관은 MMU(memory management unit)이다. 주소 버스를 반드시 거치게 되어 있는데 메모리에 접근하기 위해 주소버스를 거치기 직전에, 혹은 메모리로 부터 가져올때 주소버스로 부터 온 주소값은 전부 MMU를 통하여 offset이 더해지고 빼진다.<br><br><br>프로그램에는 일정 길이라는게 있다. 그 정해진 일정길이를 넘어가는 명령어를 한 프로그램에서 작동시키려고 하면, 해당 명령은 일단 인터럽트 트랩에 걸리게 되며, 오차가 있다면 다시 계산하여 정상 작동 시키고, 만약 아니고 치명적이라면, 프로그램은 뻗을것이다.<br>
그 정해진 일정길이값은 한계레지스터에 저장된다.<br><br><br>1. 3번
2. 3번
3. 1번
4. 한계 레지스터, 베이스 레지스터
<br><br><br><br><br><br><br><br>CPU에 가까울 수록 빠르고, 비싸고, 용량이 작다.<br>
CPU에 멀 수록 느리고, 싸고, 용량이 크다<br><br><br>레지스터 다음으로 가장 CPU와 가까운 녀석이다. 실제 역할도 메모리 역할을 한다.<br>
CPU는 바로 항상 메모리에 접근하지 않고, 캐시 메모리에 자기가 찾는 데이터가 있는지를 항상 먼저 조회하고 있다면 캐시메모리를 사용한다<br>
<br>
일반적으로 L1, L2, L3 로 구분하며, 해당 녀석들은 빠른 순서이자 CPU에 가까운 순서이다. L1, L2는 코어 내부에 있고, L3는 코어 외부에서 멀티 코어들이 전부 사용가능한 공토 공간으로 사용되는 형태를 일반적으로 취한다.<br><br><br>첫째, CPU는 최근에 접근했던 메모리 공간에 다시 접근한다.
둘째, CPU는 접근한 메모리 공간 근처 주소인 이전 혹은 이후 주소에 접근한다.
<br>위 두가지 원리에 입각하여 캐시 메모리에 올라올 데이터들이 정해진다. 현대 CPU의 캐시 적중률은 85프로 이상이다.<br><br><br>1. 레지스터, 캐시 메모리, 메모리, 보조기억장치
2. 4번
<br><br>]]></description><link>project\혼공컴운\ch06-메모리와-캐시메모리.html</link><guid isPermaLink="false">PROJECT/혼공컴운/CH06 메모리와 캐시메모리.md</guid><pubDate>Tue, 04 Feb 2025 10:39:18 GMT</pubDate></item><item><title><![CDATA[CH07 보조기억장치]]></title><description><![CDATA[ 
 <br><br><br>HDD: Hard Disk Drive<br>
자기 디스크: magnetic disk <br>
<br>
플래터: platter. 내부의 원판. 양면에 데이터가 기록되고 보통은 플래터가 여러장이 들어있음.<br>
스핀들: spindle. 플래터를 회전시키는 장치<br>
헤드: 플래터 한 면당 하나씩 위치하여 해당 면의 데이터를 기록하고 읽어들일 수 있음<br>
디스크암: 헤드의 깊이를 컨트롤하기 위한 장치<br>
트랙: 센터부터 가장자리까지 일정 두께의 원들이 모여 플래터 원판을 만드는데 이런 원 하나가 트랙<br>
섹터: 최소 데이터 저장 단위 공간. 트랙의 일부분을 담당. 섹터가 여러개가 모여 트랙을 이룸<br>
실린더: 플래터 양면, 그리고 다른 플래터들 전부 같은 xy변위의 트랙들이 존재할것. 그런 트랙들을 묶어서 실린더라고 함. 연속된 데이터를 저장할때는 일단 실린더 단위로 묶여서 연달아 저장됨. 그래야 디스크암의 탐색 운동을 줄일 수 있음.<br>
탐색시간: seek time. 디스크암이 헤더를 움직이는 시간. 찾고자 하는 트랙에 맞게 헤더를 위치시킴 <br>
회전지연: rotational latency. 플래터를 회전시켜 찾고자하는 섹터에 헤더를 위치시키는 시간<br>
전송시간: transfer time. 실제 읽어들여서 cpu까지 도달하는 시간<br>
<br>
다중 헤드 디스크: multiple head disk. 트랙별로 헤드가 위치한다. 예를들어 플래터 하나당 트랙이 3개라면 한 면당 3개. 플래터가 8장이면, 3*8*2 = 48 양면이니까. 이렇게 되면 seek time이 없어지게되고 회전지연만 남게 된다. 고정 헤드 디스크(fixed head disk)라고도 함.<br>
단일 헤드 디스크: single head disk. 디스크암이 움직이며 트랙별로 헤드를 이동시킴. 이동 헤드 디스크라고도함(movable head disk)<br>
<br><br><br>usb, sd카드, ssd, rom 등 다양한 구간에서 사용 중<br>
셀: cell. 플래시 메모리에서 데이터를 저장하는 가장 작은 단위. SLC(single level cell) MLC(multiple level cell) TLC(triple level cell) 등을 나눌때 cell을 어떻게 설계하냐에 따라서 설계가 달라진다<br>
SLC는 한 cell이 1bit를 표현, 0과 1 총 2가지  MLC는 2bit. TLC는 3bit이다. SLC가 가장 용량을 늘리기 어렵고, TLC가 용량을 늘리기 쉽다.<br>
<br>
셀cell들이 모여 페이지page를 이루고, 페이지가 모여 블록block을 이루고, 블록이 모여 플레인plane을 이루고, 플레인이 모여 다이die를 이룬다.<br>
읽기 쓰기의 최소 단위가 페이지이다.<br>
삭제의 최소 단위는 블록이다.<br>
페이지는 총 3가지 상태를 가진다. free, valid, invalid<br>
free: 자유롭게 읽고 쓰고 할 수 있는 상태이다. 비점유 상태.<br>
valid: 유효한 데이터가 페이지를 차지하고 있는 상태.<br>
invalid: 데이터가 있긴한데, 쓰레기 데이터가 차지하고 있는 상태.<br>
<br><br><br>총 4개의 페이지를 담을 수 있는 블록이 있다고 했을때 A B C 가 순서대로 들어가 있는 상황. 이때 A를 변경하여 A'로 만드는 방법은 A를 invalid 상태로 만들어 버리고 남은 페이지에 A'를 추가하여 A' B C를 저장하는 블록으로 만드는 방법을 취한다.<br>
A페이지를 직접 지울 수 없다. 왜냐하면 삭제의 단위는 블록이기 때문<br>
하지만 이렇게 되면 용량을 실제 사용도 안하는 데이터들이 너무 많이 차지하게 됨.<br>
그래서 가비지 컬렉터라는 기능을 이용하여. 블록을 검사하여 Valid 페이지만 살려서 따로 복사한뒤에 이전 블록을 비로소 삭제해버리는 기능을 자동으로 제공하도록 발전됨.<br>
<br><br><br>1. 플래터,스핀들,헤드
2. 2번
<br><br><br><br><br><br><br><br>Rebundent Array of Independent Disks: 복수 배열 독립 디스크<br>
여러개의 디스크로 커다란 하나의 디스크를 구성하는 방법<br>
가격이 저렴할 뿐만 아니라, 읽고 쓰기 행위 자체를 여러개가 분산해서 담당하게 되기때문에 성능향상 효과도 있음<br><br><br><br><br>진짜 연속된 데이터가 있으면 분산된 만큼 하나씩 분산해서 쓰고 읽는 방법. 가장 단순하고, 가장 군더더기 없이 읽고 씀. 하지만 디스크 하나라도 고장나면 데이터가 손실되게됨.<br><br><br>RAID0를 2개로 복제하여 복사본을 항상 쓰는 방법. 디스크 중 하나가 고장 나도 복제본 디스크가 있기 때문에 안정성 확보. 그런데 그만큼 용량은 비효율적.<br><br><br>연속된 데이터들을  RAID0처럼 분산 저장하는건 맞는데 이때 패리티 정보를 담는 전용 디스크를 두는 방법. 이 패리티 데이터로 인해 다른 디스크에 저장된 데이터에 오류는 없는지 체크가능하고, 복구도 가능함.<br>
하지만, 패리티 정보를 누적하여 만들기 위해서 다른 디스크에 데이터 쓰기가 이뤄질때 마다 한번씩 페리티 정보도 써야하기 때문에 패리티 디스크에 과부하가 걸리는 구조.<br><br><br>패리티 디스크에 과부하가 걸리는 구조를 깨기 위해. 모든 디스크가 데이터를 저장하는 역할 뿐만아니라 분산해서 패리티 정보를 저장하는 방식. <br><br><br>패리티 데이터 자체에대한 복구까지 고려된 방식. 각기 다른 디스크에 같은 패리티 데이터를 복제하여 저장하도록 담당시킨다. 당연히 쓰기에 더 많은 자원이 든다.<br><br><br><br>1. 2번
2. 3번
3. RAID6
<br><br><br>]]></description><link>project\혼공컴운\ch07-보조기억장치.html</link><guid isPermaLink="false">PROJECT/혼공컴운/CH07 보조기억장치.md</guid><pubDate>Tue, 04 Feb 2025 09:43:36 GMT</pubDate></item><item><title><![CDATA[CH08 입출력장치]]></title><description><![CDATA[ 
 <br><br><br>다양한 여러 장치들은 각자의 속도, 처리량, 요구 데이터 등이 전부 다르기 때문에 이걸 CPU가 각 장치마다 맞춤형으로 맞춰 줄 수가 없다. 그래서 중간 다리 역할을 하는 녀석이 장치 컨트롤러이다.<br>
장치 컨트롤러를 그러기 위해 기본적으로 저장 장치가 필요하다. CPU에 보낼 데이터, 지금 장치의 상태 등을 저장해야 되기 때문임. 장치 컨트롤러 내부에는 데이터 레지스터, 상태 레지스터, 제어 레지스터가 있음<br>
데이터 레지스터: 입출력 장치가 CPU에 보내고 싶은 데이터를 모아 놓는 공간. 출력의 경우에는 그 반대<br>
상태 레지스터: 입출력 장치가 대기 상태인지, 아직 막 작업 중인 상태인지 등을 저장<br>
제어 레지스터: CPU가 입출력 장치에 보낸 명령을 저장하는 공간<br><br><br>장치 컨트롤러가 CPU와 다양한 입출력 장치들이 서로 소통하기 위한 하드웨어적 장치였다면, 장치 드라이버는 중개 소프트웨어이다.<br>
OS가 기본적으로 장치 드라이버를 인식하여 설치해야하며, 설치가 안되었다면, 그 어떤 입출력 장치도 소통할 수 없다.<br><br><br>1. 1번, 3번
2. 2번
3. 장치 컨트롤러, 프로그램
4. 2번
<br><br><br><br><br><br><br><br>프로그램이 입출력 장치를 컨트롤 하는 경우에 프로그램 입출력 방식이라고 함.<br>
장치 컨트롤러 내부에는 CPU와 소통하기 위한 레지스터들이 있는데, 제어 레지스터에 명령어를 쓰고, 그 명령어로 입출력 장치가 인식하여 상태 레지스터가 바뀌고, 상태 레지스터가 바뀌면 CPU가 입출력 장치에 보내고 싶은 데이터가 써지거나 혹은 데이터 레지스터에 있는 데이터를 CPU가 읽는 방식으로 동작하게됨.<br>
그런데 여기서 결국 CPU는 메인보드에 부착된 어떤 입출력 장치의 장치 컨트롤러의 레지스터에 접근하고자 할때는 고유한 주소값으로 접근해야 될텐데. 그 방법이 두 가지가 있음. <br>
첫째, CPU는 메모리와 소통한다. 이런 메모리와 소통하는 기존 방식과 다르지 않은 명령어와 주소로 입출력 장치와 소통하는 memory mapped I/O 방식이다. 메모리 일부 공간에 입출력 장치 레지스터의 주소랑 메핑된 공간을 할당하여, 마치 그 공간이 장치 컨트롤러의 공간인냥 사용하는 방법<br>
둘째, 메모리에 접근하는 방법은 시스템 버스의 데이터 버스, 제어버스, 주소버스 를 이용하여 필요할때 메모리에 접근하는 방식이다. 이것처럼 입출력 장치들을 묶어서 소통할 수 있는 버스를 입출력장치 버스를 둠으로 써 모든 입출력 장치에 접근하는 방법을 뚫는 방법. 이는 메모리와 소통할때 쓰이는 일반적인 명령어 집합이 아닌 다른 명령어 특히 다른 오퍼랜드를 사용 할 수 밖에 없는 방식이다. 이를 isolated I/O 고립형 입출력 방식이라고 한다.<br><br><br>프로그램이 인터럽트를 발생시킬 수도 있고, 하드웨어가 인터럽트를 발생시킬 수도 있다. 하여간 인터럽트를 통해 CPU가 클럭 신호마다 체크하여 입출력 장치와 적절한 소통을 하는 방식이다.<br>
그런데 입출력 장치가 한두개도 아니고, 동시 다발적으로 특히 같은 타이밍에 CPU에 마구 인터럽트를 던져 놓는 상황은 충분히 발생한다. 이를 컨트롤하기 위해 PIC Programmable Interrupt Controller 라는 하드웨어가 메인보드에 있어서 CPU에게 전달될 인터럽트들을 제어하는 중개 역할을 한다.<br>
항상 과장되게 극단적으로 생각해야한다. 입출력장치 하드웨어는 수백개가 존재할 수 있다. 이를 PIC하나가 감당하게 하는 설계를 하지 않는다. PIC는 상위 PIC와 연결되어 어떤 하위 입출력 장치 그룹들의 인터럽트들을 우선 처리할지 등을 또 컨트롤하는 구조를 취한다.<br><br><br>Direct Memory Access Controller라는  하드웨어를 통하여 입출력장치가 메모리에 접근해야할때 CPU가 두번 세번 일하는걸 방지한다.<br>
CPU의 부담을 덜어서 간단한 단순 동작을 대신 처리하게 하는 장치이다.<br>
CPU는 DMA 컨트롤러에 처리해야할 명령들을 전달하고, 해당 명령을 이용하여 입출력장치와 소통, 제어 레지스터, 상태 레지스터, 데이터 레지스터를 모두 사용한 결과가 완료되면, 그제서야 CPU에 일처리 다했어요 인터럽트만을 CPU에게 쏜다. CPU는 다른 복잡한 작업을 하는 동안 입출력 장치 동작 정도는 DMA 컨트롤러가 대신해주는 것<br><br><br>DMA 뿐만 아니라, 입출력 장치가 무언가를 하여 transfer 즉 통신을 할때는 반드시 메인보드의 버스를 이용해야 한다. 그런데 버스는 고속도로가 아닌 기차 선로여서 한번에 한 장치만 점유할 수 있는 구조이다.<br>
만약 입출력 버스라는게 없다면, 시스템 버스를 사용해야되어 CPU가 제대로 일을 할 수가 없게 된다.<br>
그래서 등장한게 입출력버스이고, 대표적인건 PCI 버스가 있다. Peripheral Component Interconnect 그 발전형인 PCI Express PCIe 버스가 현재 주류이다.<br><br><br>1. 2번
2. A 다음 B
3. 3번
4. 메모리 맵 입출력 방식
5. 고립형 입출력 방식
<br><br><br><br><br>]]></description><link>project\혼공컴운\ch08-입출력장치.html</link><guid isPermaLink="false">PROJECT/혼공컴운/CH08 입출력장치.md</guid><pubDate>Tue, 04 Feb 2025 10:29:24 GMT</pubDate></item><item><title><![CDATA[linebreak]]></title><description><![CDATA[ 
 <br><br>]]></description><link>template\linebreak.html</link><guid isPermaLink="false">template/linebreak.md</guid><pubDate>Wed, 05 Feb 2025 06:14:32 GMT</pubDate></item><item><title><![CDATA[learning]]></title><description><![CDATA[ 
 <br><br>learning]]></description><link>readme.html</link><guid isPermaLink="false">README.md</guid><pubDate>Wed, 08 Jan 2025 12:02:01 GMT</pubDate></item></channel></rss>